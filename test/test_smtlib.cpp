
#include "Encodings/Encodings.hpp"
#include "LogicBlock/SMTLibLogicBlock.hpp"
#include "LogicBlock/SMTLibLogicModel.hpp"
#include "LogicTerm/Logic.hpp"
#include "LogicTerm/LogicTerm.hpp"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
class TestSMTLib: public testing::TestWithParam<logicbase::OpType> {
protected:
    void SetUp() override {
    }
};
TEST(TestSMTLib, ConstructDestruct) {
    using namespace logicbase;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, std::cout);
}

TEST(TestSMTLib, TestPrint) {
    using namespace logicbase;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, std::cout);

    LogicTerm a = smtLibLogic->makeVariable("a", CType::BOOL);
    LogicTerm b = smtLibLogic->makeVariable("b", CType::INT);
    LogicTerm c = smtLibLogic->makeVariable("c", CType::REAL);
    LogicTerm d = smtLibLogic->makeVariable("d", CType::BITVECTOR, 8);

    LogicTerm t = a && (b == LogicTerm(1));
    t.print(std::cout);
    t.prettyPrint(std::cout);

    LogicTerm f = (c == LogicTerm(1.0)) && (d == LogicTerm(1, 8));
    f.print(std::cout);
    f.prettyPrint(std::cout);

    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(f);

    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_BV);
    smtLibLogic->produceInstance();
}

TEST(TestSMTLib, TestBasicBooleanAnd) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (and p_0 (not p_0)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t = p && !p;
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBasicBooleanOrXor) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (xor p_0 (not p_0)))\n"
                         "(assert (or p_0 (not p_0)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p  = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t  = p || !p;
    LogicTerm t2 = p != !p;
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBasicBooleanImpl) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (=> p_0 (not p_0)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t = LogicTerm::implies(p, !p);
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBasicBooleanIte) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (ite p_0 (not p_0) p_0))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t = LogicTerm::ite(p, !p, p);
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmetic) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (= (- x_0 y_1) (+ (+ x_0 (- 0 y_1)) 1)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t = (x - y) == (x + (LogicTerm(0) - y) + LogicTerm(1));
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmeticMul) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (= (+ x_0 (* y_1 2)) 20))\n"
                         "(assert (= (- x_0 y_1) 2))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x  = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y  = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t  = (x + (LogicTerm(2) * y)) == LogicTerm(20);
    LogicTerm t2 = (x - y) == LogicTerm(2);
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmeticDiv) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (= (+ x_0 (* y_1 2)) 20))\n"
                         "(assert (= (div x_0 y_1) 2))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x  = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y  = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t  = (x + (LogicTerm(2) * y)) == LogicTerm(20);
    LogicTerm t2 = (x / y) == LogicTerm(2);
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmeticGTLT) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (< (+ x_0 (* y_1 2)) 20))\n"
                         "(assert (> (div x_0 y_1) 2))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x  = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y  = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t  = (x + (LogicTerm(2) * y)) < LogicTerm(20);
    LogicTerm t2 = (x / y) > LogicTerm(2);
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmeticGTELTE) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (<= (+ x_0 (* y_1 2)) 20))\n"
                         "(assert (>= (div x_0 y_1) 2))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x  = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y  = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t  = (x + (LogicTerm(2) * y)) <= LogicTerm(20);
    LogicTerm t2 = (x / y) >= LogicTerm(2);
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBitVectorArithmeticAnd) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 (_ BitVec 8))\n"
                         "(declare-const y_1 (_ BitVec 8))\n"
                         "(assert (= x_0 (bvand x_0 y_1)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x = smtLibLogic->makeVariable("x", CType::BITVECTOR, 8);
    LogicTerm y = smtLibLogic->makeVariable("y", CType::BITVECTOR, 8);
    LogicTerm t = x == (x & y);
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBitVectorArithmeticOr) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 (_ BitVec 8))\n"
                         "(declare-const y_1 (_ BitVec 8))\n"
                         "(assert (= x_0 (bvor x_0 y_1)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x = smtLibLogic->makeVariable("x", CType::BITVECTOR, 8);
    LogicTerm y = smtLibLogic->makeVariable("y", CType::BITVECTOR, 8);
    LogicTerm t = x == (x | y);
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBitVectorArithmeticXor) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 (_ BitVec 8))\n"
                         "(declare-const y_1 (_ BitVec 8))\n"
                         "(assert (= x_0 (bvxor x_0 y_1)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x = smtLibLogic->makeVariable("x", CType::BITVECTOR, 8);
    LogicTerm y = smtLibLogic->makeVariable("y", CType::BITVECTOR, 8);
    LogicTerm t = x == (x ^ y);
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestModelInt) {
    using namespace logicbase;

    std::stringstream ss;

    std::string output = "(\n"
                         "(define-fun x () Int 8)\n"
                         "(define-fun y () Int 6)\n"
                         ")\n";

    smtliblogic::SMTLibLogicModel model(output);

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);
    LogicTerm                                         x           = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm                                         y           = smtLibLogic->makeVariable("y", CType::INT);

    ASSERT_EQ(model.getIntValue(x, nullptr), 8);
    ASSERT_EQ(model.getIntValue(y, nullptr), 6);
}

TEST(TestSMTLib, TestModelBool) {
    using namespace logicbase;

    std::stringstream ss;

    std::string output = "(\n"
                         "(define-fun x () Bool true)\n"
                         "(define-fun y () Bool false)\n"
                         ")\n";

    smtliblogic::SMTLibLogicModel model(output);

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);
    LogicTerm                                         x           = smtLibLogic->makeVariable("x", CType::BOOL);
    LogicTerm                                         y           = smtLibLogic->makeVariable("y", CType::BOOL);

    ASSERT_EQ(model.getBoolValue(x, nullptr), true);
    ASSERT_EQ(model.getBoolValue(y, nullptr), false);
}

TEST(TestSMTLib, TestModelFloat) {
    using namespace logicbase;

    std::stringstream ss;

    std::string output = "(\n"
                         "(define-fun x () Real 1.0)\n"
                         "(define-fun y () Real 0.7)\n"
                         ")\n";

    smtliblogic::SMTLibLogicModel model(output);

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);
    LogicTerm                                         x           = smtLibLogic->makeVariable("x", CType::BOOL);
    LogicTerm                                         y           = smtLibLogic->makeVariable("y", CType::BOOL);

    ASSERT_EQ(model.getRealValue(x, nullptr), 1);
    ASSERT_EQ(model.getRealValue(y, nullptr), 0.7);
}

TEST(TestSMTLib, TestModelBitVector) {
    using namespace logicbase;

    std::stringstream ss;

    std::string output = "(\n"
                         "(define-fun x () (_ BitVector 8) #x00)\n"
                         "(define-fun y () (_ BitVector 8) #x10)\n"
                         ")\n";

    smtliblogic::SMTLibLogicModel model(output);

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);
    LogicTerm                                         x           = smtLibLogic->makeVariable("x", CType::BITVECTOR, 8);
    LogicTerm                                         y           = smtLibLogic->makeVariable("y", CType::BITVECTOR, 8);

    ASSERT_EQ(model.getBitvectorValue(x, nullptr), 0);
    ASSERT_EQ(model.getBitvectorValue(y, nullptr), 2);
}

TEST(TestSMTLib, TestModelWrongType) {
    using namespace logicbase;

    std::stringstream ss;

    std::string output = "(\n"
                         "(define-fun x () (_ BitVector 8) #x00)\n"
                         "(define-fun y () Int 1)\n"
                         "(define-fun z () Bool true)\n"
                         "(define-fun a () Real 1.0)\n"
                         ")\n";

    smtliblogic::SMTLibLogicModel model(output);

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);
    LogicTerm                                         x           = smtLibLogic->makeVariable("x", CType::BITVECTOR, 16);
    LogicTerm                                         y           = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm                                         z           = smtLibLogic->makeVariable("z", CType::BOOL);
    LogicTerm                                         a           = smtLibLogic->makeVariable("a", CType::REAL);

    ASSERT_THROW(model.getBitvectorValue(x, nullptr), std::runtime_error);
    ASSERT_THROW(model.getBitvectorValue(y, nullptr), std::runtime_error);
    ASSERT_THROW(model.getBitvectorValue(z, nullptr), std::runtime_error);
    ASSERT_THROW(model.getBitvectorValue(a, nullptr), std::runtime_error);

    ASSERT_THROW(model.getIntValue(a, nullptr), std::runtime_error);
    ASSERT_THROW(model.getIntValue(x, nullptr), std::runtime_error);
    ASSERT_THROW(model.getIntValue(z, nullptr), std::runtime_error);

    ASSERT_THROW(model.getBoolValue(x, nullptr), std::runtime_error);
    ASSERT_THROW(model.getBoolValue(y, nullptr), std::runtime_error);
    ASSERT_THROW(model.getBoolValue(a, nullptr), std::runtime_error);

    ASSERT_THROW(model.getRealValue(x, nullptr), std::runtime_error);
    ASSERT_THROW(model.getRealValue(y, nullptr), std::runtime_error);
    ASSERT_THROW(model.getRealValue(z, nullptr), std::runtime_error);
}

TEST(TestSMTLib, TestModelGetValue) {
    using namespace logicbase;

    std::stringstream ss;

    std::string output = "(\n"
                         "(define-fun x () (_ BitVector 8) #x00)\n"
                         "(define-fun y () Int 1)\n"
                         "(define-fun z () Bool true)\n"
                         "(define-fun a () Real 1.0)\n"
                         ")\n";

    smtliblogic::SMTLibLogicModel model(output);

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);
    LogicTerm                                         x           = smtLibLogic->makeVariable("x", CType::BITVECTOR, 8);
    LogicTerm                                         y           = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm                                         z           = smtLibLogic->makeVariable("z", CType::BOOL);
    LogicTerm                                         a           = smtLibLogic->makeVariable("a", CType::REAL);

    ASSERT_EQ(model.getValue(x, nullptr).getBitVectorValue(), 0);
    ASSERT_EQ(model.getValue(y, nullptr).getIntValue(), 1);
    ASSERT_EQ(model.getValue(z, nullptr).getBoolValue(), true);
    ASSERT_EQ(model.getValue(a, nullptr).getFloatValue(), 1.0);
}
