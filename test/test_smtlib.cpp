
#include "Encodings/Encodings.hpp"
#include "LogicBlock/SMTLibLogicBlock.hpp"
#include "LogicTerm/Logic.hpp"
#include "LogicTerm/LogicTerm.hpp"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
class TestSMTLib: public testing::TestWithParam<logicbase::OpType> {
protected:
    void SetUp() override {
    }
};
TEST(TestSMTLib, ConstructDestruct) {
    using namespace logicbase;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, std::cout);
}

TEST(TestSMTLib, TestPrint) {
    using namespace logicbase;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, std::cout);

    LogicTerm a = smtLibLogic->makeVariable("a", CType::BOOL);
    LogicTerm b = smtLibLogic->makeVariable("b", CType::INT);
    LogicTerm c = smtLibLogic->makeVariable("c", CType::REAL);
    LogicTerm d = smtLibLogic->makeVariable("d", CType::BITVECTOR, 8);

    LogicTerm t = a && (b == LogicTerm(1));
    t.print(std::cout);
    t.prettyPrint(std::cout);

    LogicTerm f = (c == LogicTerm(1.0)) && (d == LogicTerm(1, 8));
    f.print(std::cout);
    f.prettyPrint(std::cout);

    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(f);

    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_BV);
    smtLibLogic->produceInstance();
}

TEST(TestSMTLib, TestBasicBooleanAnd) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (and p_0 (not p_0)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t = p && !p;
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBasicBooleanOrXor) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (xor p_0 (not p_0)))\n"
                         "(assert (or p_0 (not p_0)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p  = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t  = p || !p;
    LogicTerm t2 = p != !p;
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBasicBooleanImpl) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (=> p_0 (not p_0)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t = LogicTerm::implies(p, !p);
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestBasicBooleanIte) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (ite p_0 (not p_0) p_0))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t = LogicTerm::ite(p, !p, p);
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmetic) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (= (- x_0 y_1) (+ (+ x_0 (- 0 y_1)) 1)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t = (x - y) == (x + (LogicTerm(0) - y) + LogicTerm(1));
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmeticMul) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (= (+ x_0 (* y_1 2)) 20))\n"
                         "(assert (= (- x_0 y_1) 2))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x  = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y  = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t  = (x + (LogicTerm(2) * y)) == LogicTerm(20);
    LogicTerm t2 = (x - y) == LogicTerm(2);
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmeticDiv) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (= (+ x_0 (* y_1 2)) 20))\n"
                         "(assert (= (div x_0 y_1) 2))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x  = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y  = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t  = (x + (LogicTerm(2) * y)) == LogicTerm(20);
    LogicTerm t2 = (x / y) == LogicTerm(2);
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmeticGTLT) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (< (+ x_0 (* y_1 2)) 20))\n"
                         "(assert (> (div x_0 y_1) 2))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x  = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y  = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t  = (x + (LogicTerm(2) * y)) < LogicTerm(20);
    LogicTerm t2 = (x / y) > LogicTerm(2);
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}

TEST(TestSMTLib, TestIntegerArithmeticGTELTE) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (<= (+ x_0 (* y_1 2)) 20))\n"
                         "(assert (>= (div x_0 y_1) 2))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x  = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y  = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t  = (x + (LogicTerm(2) * y)) <= LogicTerm(20);
    LogicTerm t2 = (x / y) >= LogicTerm(2);
    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(t2);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}
