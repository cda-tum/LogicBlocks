
#include "Encodings/Encodings.hpp"
#include "LogicBlock/SMTLibLogicBlock.hpp"
#include "LogicTerm/Logic.hpp"
#include "LogicTerm/LogicTerm.hpp"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
class TestSMTLib: public testing::TestWithParam<logicbase::OpType> {
protected:
    void SetUp() override {
    }
};
TEST(TestSMTLib, ConstructDestruct) {
    using namespace logicbase;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, std::cout);
}

TEST(TestSMTLib, TestPrint) {
    using namespace logicbase;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, std::cout);

    LogicTerm a = smtLibLogic->makeVariable("a", CType::BOOL);
    LogicTerm b = smtLibLogic->makeVariable("b", CType::INT);
    LogicTerm c = smtLibLogic->makeVariable("c", CType::REAL);
    LogicTerm d = smtLibLogic->makeVariable("d", CType::BITVECTOR, 8);

    LogicTerm t = a && (b == LogicTerm(1));
    t.print(std::cout);
    t.prettyPrint(std::cout);

    LogicTerm f = (c == LogicTerm(1.0)) && (d == LogicTerm(1, 8));
    f.print(std::cout);
    f.prettyPrint(std::cout);

    smtLibLogic->assertFormula(t);
    smtLibLogic->assertFormula(f);

    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_BV);
    smtLibLogic->produceInstance();
}

TEST(TestSMTLib, TestBasicBoolean) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_UF)\n"
                         "(declare-const p_0 Bool)\n"
                         "(assert (and p_0 (not p_0)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm p = smtLibLogic->makeVariable("p", CType::BOOL);
    LogicTerm t = p && !p;
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_UF);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}
TEST(TestSMTLib, TestIntegerArithmetic) {
    using namespace logicbase;

    std::stringstream ss;

    std::unique_ptr<smtliblogic::SMTLogicBlock> const smtLibLogic = std::make_unique<smtliblogic::SMTLogicBlock>(false, ss);

    std::string output = "; Generated by LogicBlock\n"
                         "(set-option :produce-models true)\n"
                         "(set-logic QF_LIA)\n"
                         "(declare-const x_0 Int)\n"
                         "(declare-const y_1 Int)\n"
                         "(assert (= (- x_0 y_1) (+ (+ x_0 (- 0 y_1)) 1)))\n"
                         "(check-sat)\n"
                         "(get-model)\n"
                         "(exit)\n";

    LogicTerm x = smtLibLogic->makeVariable("x", CType::INT);
    LogicTerm y = smtLibLogic->makeVariable("y", CType::INT);
    LogicTerm t = (x - y) == (x + (LogicTerm(0) - y) + LogicTerm(1));
    smtLibLogic->assertFormula(t);
    smtLibLogic->setOutputLogic(smtliblogic::SMTLibLogic::QF_LIA);
    smtLibLogic->produceInstance();

    ASSERT_EQ(ss.str(), output);
}
